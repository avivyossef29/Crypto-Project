# exploit.py
# Skeleton for building your CRIME attack
import requests
import string
import time
import statistics
from enum import Enum


class DifficultyLevel(Enum):
    NORMAL = "normal"
    HARD = "hard"


def get_response_length(url, payload, difficulty, num_samples=1):
    """
    Makes a request to the server and returns the response length
    Args:
        url: Server URL
        payload: Your input string
        difficulty: NORMAL or HARD
        num_samples: Number of samples to take (use multiple for HARD mode)
    Returns:
        Median response length or None on error
    """
    lengths = []
    for _ in range(num_samples):
        try:
            response = requests.get(
                f"{url}?payload={payload}&difficulty={difficulty.value}"
            )
            data = response.json()
            if "error" in data:
                print(f"Server error: {data['error']}")
                return None
            lengths.append(data["length"])
        except Exception as e:
            print(f"Error making request: {e}")
            return None
        time.sleep(0.1)  # Be nice to the server

    return statistics.median(lengths) if lengths else None


def find_flag(url):
    # CRIME Attack Challenge.

    difficulty = None
    difficulty = DifficultyLevel.NORMAL
    # difficulty = DifficultyLevel.HARD
    assert (
        difficulty
    ), "Please choose a difficulty level, Normal: (Compression). Hard: (Compression + Encryption)."

    """
    TODO: Implement your attack here!

    Tips for building your exploit:
    1. We know the flag format is CTF_FLAG{...}
    2. The server response contains 'secret_flag: <THE_FLAG>'
    3. Compression works better when strings match
    4. In HARD mode, use multiple samples to handle encryption noise
    """
    charset = string.ascii_letters + string.digits + "{}_}"  # Possible flag characters
    known = "CTF_FLAG{"  # Starting point

    print(f"Starting attack in {difficulty.name} mode...")
    print(f"Known prefix: {known}")

    # TODO: Implement your attack loop here
    # while "}" not in known:
    #     best_length = float('inf')
    #     best_char = None
    #
    #     # Try each possible next character
    #     for char in charset:
    #         # TODO: Create a payload that will compress well if correct
    #         # TODO: Get response length
    #         # TODO: Update best_char if this produces better compression
    #         pass
    #
    #     # TODO: Add best_char to known prefix
    #     pass

    return known


def main():
    url = "http://localhost:8443"  # Update this to the actual server URL

    flag = find_flag(url)

    if flag and flag.endswith("}"):
        print(f"\nSuccess! Found flag: {flag}")
    else:
        print("\nAttack failed or was interrupted")


if __name__ == "__main__":
    main()
